Вычислительная математика
=============
Лабораторные работы по Вычислительной математике.

[![GitHub stars][stars-shield]][stars-url]
[![GitHub issues][issues-shield]][issues-url]
[![GitHub][license-shield]][license-url]
![GitHub repo size](https://img.shields.io/github/repo-size/KirillShakhov/VM.Labs)
![GitHub last commit](https://img.shields.io/github/last-commit/KirillShakhov/VM.Labs)
[![Java CI with Maven](https://github.com/KirillShakhov/VM.Labs/actions/workflows/maven.yml/badge.svg)](https://github.com/KirillShakhov/VM.Labs/actions/workflows/maven.yml)

Лабораторная работа 1. «Решение системы линейных алгебраических уравнений СЛАУ»
-------------------------------------------------------------------------------
Вариант: Метод простых итераций

* В программе численный метод должен быть реализован в виде отдельной подпрограммы или класса, в который исходные данные передаются в качестве параметров, выходные - тоже (либо возвращаемое значение).
* Размерность матрицы n<=20 (задается из файла или с клавиатуры - по выбору конечного пользователя).
* Должна быть реализована возможность ввода коэффициентов матрицы,  как с клавиатуры, так и из файла (по выбору конечного пользователя).

Обязательно: Тестовые данные на матрице большого размера (5x5 / 6x6...) + в отчёт с решением.

Для итерационных методов должно быть реализовано:
* Точность задается с клавиатуры/файла
* Проверка диагонального преобладания (в случае, если диагональное преобладание в исходной  матрице отсутствует, сделать перестановку строк/столбцов до тех пор, пока преобладание не будет достигнуто). В случае невозможности достижения диагонального преобладания - выводить соответствующее сообщение.
* Вывод вектора неизвестных:
* Вывод количества итераций, за которое было найдено решение
* Вывод вектора погрешностей:

TAGS: Метод простых итераций для СЛАУ Java. Метод простых итераций для Систем линейных алгебраических уравнений Java.
Проверка диагонального преобладания Java. Перестановка строк в матрицe Java.


Лабораторная работа 2. «Решение нелинейных уравнений и систем нелинейных уравнений»
-----------------------------------------------------------------------------------
Вариант: 2aб (2 - метод простых итераций, a - метод деления пополам, б - метод хорд)

Для нелинейных уравнений должны быть реализованные метод деления пополам и метод хорд.
Для систем нелинейных уравнений реализовать метод простых итераций.
Программа должна рисовать графики для функций.

TAGS: Метод простых итераций для СНУ. Метод простых итераций для систем нелинейных уравнений Java.
Метод деления пополам для нелинейных уравнений Java. Метод хорд для нелинейных уравнений Java.

Лабораторная работа 3. «Численное интегрирование»
-------------------------------------------------
Вариант: Метод прямоугольников, Метод трапеций

Нахождение интеграла методом прямоугольников(левых, правых, средних).
Нахождение интеграла методом трапеций.

Пользователь выбирает функцию, интеграл которой он хочет вычислить (3-5 функций), из тех, которые предлагает программа.

В численный метод должен быть передан параметр-агрегат на подпрограмму вычисления значения функции в точке x.

Пользователь задает пределы интегрирования и точность. 

NOTE! Если нижний предел интегрирования >= верхнего предела - интеграл должен считаться корректно!

В результате должны получить:
*. значение интеграла
*. количество разбиений, на которое пришлось разбить
*. полученную погрешность 

Для оценки погрешности использовать оценку Рунге.

TAGS: Нахождение интеграла методом прямоугольников(левых, правых, средних) Java.
Нахождение интеграла методом трапеций Java. Расчет погрешности правилом Рунге Java.
Нахождение разрывов функции Java. Разделение функции на промежутки Java. 
Расчет погрешности правилом Рунге. Нахождение разрывов функции. Разделение функции на промежутки.

Лабораторная работа 4. «Интерполирование Лагранжа»
-------------------------------------------------

Вычислительная математика ЛР4. Вариант: Интерполирование Лагранжа (ИТМО, ПИиКТ, 2 курс)

Вариант: Метод Лагранжа

Для интерполяции необходимо подготовить 3-4 набора данных (в зависимости от функции).
Исходные данные должны быть подготовлены следующим образом: 
* Берем функцию
* Берем точки x (точки не обязательно упорядочены)
* значение y получаем на основе данных выбранной функции

Например:
* берем sinx
* 1) берем 3-4 точки на интервале 0 по 2Пи(шаг более менее большой)
  2) берем 8-10 точек на интервале 0 по 2Пи (уменьшаем шаг)
  3) точки с предыдущего примера, только для одной точки изменяем значение y, например
было 0.8, делаем -5, смотрим как ведет себя интерполяция.
  4) берем 8-10 точек на интервале 0 по 50Пи

В итоге, должны получить график, на котором одним цветом исходная функция (sinx), а другим цветом полученный график в результате интерполяции, и на графике должны быть отмечены сами точки (узлы) интерполяции. 
Интерполяционный график должен пройти через исходные эти точки.
Программа должна позволять найти значение y (отдельное поле) для любого введенного x
(рассчитывается на основе построенного интерполяционного многочлена).

TAGS: Интерполирование методом Лагранжа на Java. Интерполирование и линейное аппроксимирование на Java. Метод Лагранжа и построение графиков. Нахождение точки по исходным данным.

[stars-shield]: https://img.shields.io/github/stars/KirillShakhov/VM.Labs?style=social
[stars-url]: https://github.com/KirillShakhov/VM.Labs/stargazers
[issues-shield]: https://img.shields.io/github/issues/KirillShakhov/VM.Labs
[issues-url]: https://github.com/KirillShakhov/VM.Labs/issues
[license-shield]: https://img.shields.io/github/license/KirillShakhov/VM.Labs
[license-url]: https://github.com/KirillShakhov/VM.Labs/blob/master/LICENSE
